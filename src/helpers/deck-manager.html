<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="shared-styles.html">

<dom-module id="deck-manager">
  <template>
    <style include="shared-styles">
      :host {
        display: block;
        padding: 0px;
      }
    </style>
  </template>

  <script>
    class DeckManager extends Polymer.Element {
      static get is() { return 'deck-manager'; }
      
      static get properties() {
        return {
          apiUrl: {
            type: String,
            value: "http://ygodb.pe.hu/api/api.php/search?"
          },
          downloading: {
            type: Boolean,
            value: false
          },
          mainDeck: {
            type: Array,
            value: function () { return []; }
          },
          extraDeck: {
            type: Array,
            value: function () { return []; }
          },
          sideDeck: {
            type: Array,
            value: function () { return []; }
          }
        };
      }
      
      ready() {
        super.ready();
        document.addEventListener('create-card', e => this.createCard(e));        
        document.addEventListener('remove-card', e => this.removeCard(e));
        document.addEventListener('clear-card-from-main', e => this.clearCard(e));
        document.addEventListener('clear-card-from-side', e => this.clearCard(e));
        document.addEventListener('clear-card-from-extra', e => this.clearCard(e));
        document.addEventListener('download-ydk', e => this.downloadYDK(e));
      }

      isID (o) {
        return ! isNaN (o-0) && o !== null && o !== "" && o !== false;
      }
    
      isName (o) {
        return isNaN (o) && o !== null && o !== "" && o !== false;
      }

      createCard(e, reference = this) {
        if(reference.downloading) {
          window.setTimeout(reference.createCard, 10, e, reference);
        } else {
          reference._createCard(e.detail.card, e.detail.deck);
        }
      }

      _createCard(card, deck) {
        this.downloading = true;
        var cardClone = this._findCardInDeck(card, deck);
        if (cardClone != null) {
          this.addCard(cardClone, deck);
        } else {
          var isID = this.isID(card)
          var isName = this.isName(card);
          var apiSearch = "";
          if (isID) {
            apiSearch = "id";
          } else if (isName) {
            apiSearch = "name";
          }

          var url = this.apiUrl + apiSearch + "=" + card;
          var xhr = new XMLHttpRequest();
          var reference = this;
          xhr.open("GET", url, true);
          xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 && xhr.status == 200) {
              var ygoprodb = JSON.parse(xhr.responseText);
              reference.addCard(ygoprodb, deck);
            } else {
              reference.downloading = false;
            }
          };

          xhr.send();
        }
      }

      _findCardInDeck(card, deck) {
        var deck = this.spliceExtraDeck(card, deck);
        var pendingDeck = this._getDeck(deck);
        for (var i = 0; i < pendingDeck.length; i++) {
          for (var j = 0; j < pendingDeck[i].ids.length; j++) {
            if (card == pendingDeck[i].name || card == pendingDeck[i].ids[j]) {
              return pendingDeck[i];
            }
          }
        }
      }

      addCard(card, deck) {
        var name = card.name;
        var deck = this.spliceExtraDeck(card, deck);
        var pendingDeck = this._getDeck(deck);

        var count = 0;
        pendingDeck.forEach(function(currentCard) {
          if (name == currentCard.name) { 
            count++;
          }
        });

        if (count < 3) {
          if (count == 0) {
            count++;
            document.dispatchEvent(new CustomEvent('add-card-to-' + deck, {detail: {card: card}}));
          } else {
            count++;
            document.dispatchEvent(new CustomEvent(deck + '-update-count-' + name, {detail: {count: count}}));
          }
          console.log(name + " is being added to " + deck);
          pendingDeck.push(card);
          document.dispatchEvent(new CustomEvent('draw-card', {detail: {card: card, deck: deck}}));
        } else {
          window.alert("Hey now! You can only have three of the same card in a deck."); //Placeholder
        }
        this._setDeck(deck, pendingDeck);
        this.downloading = false;
      }

      removeCard(e) {
        var deck = this.spliceExtraDeck(e.detail.card, e.detail.card.deck);
        var pendingDeck = this._getDeck(deck);
        var itemToRemove;
        for (var i = 0; i < pendingDeck.length; i++) {
          if (e.detail.card.name == pendingDeck[i].name) {
            itemToRemove = i;
            break;
          }
        }
        
        console.log(pendingDeck[itemToRemove].name + " is being removed from " + deck);
        pendingDeck.splice(itemToRemove, 1);

        this._setDeck(deck, pendingDeck);
      }

      clearCard(e) {
        for (var i = 0; i < e.detail.card.count; i++) {
          document.dispatchEvent(new CustomEvent('remove-card', {detail: {card: e.detail.card}}));
        }
      }

      isExtraDeckMonster(card) {
        if (card.allTypes) { 
          for (var i = 0; i < card.allTypes.length; i++) {
            if (card.allTypes[i] == "Fusion" || card.allTypes[i] == "Link" || card.allTypes[i] == "Synchro" || card.allTypes[i] == "Xyz") return true;
          }
        }
        return false;
      }

      spliceExtraDeck(card, deck) {
        return this.isExtraDeckMonster(card) && deck == "main" ? "extra": deck;
      }

      downloadYDK(e) {
        var textToSave = this._createYDK();
        var textToSaveAsBlob = new Blob([textToSave], {type:"text/plain"});
        var textToSaveAsURL = window.URL.createObjectURL(textToSaveAsBlob);
        var fileNameToSaveAs = e.detail.deckname + ".ydk";
    
        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.href = textToSaveAsURL;
        downloadLink.style.display = "none";

        downloadLink.click();
      }

      _createYDK() {
        var prefix = "#Created by Ultimate Deck Builder\n";
        return prefix + this._createYDKFor("main") + this._createYDKFor("extra") + this._createYDKFor("side");
      }

      _createYDKFor(deck) {
        var YDK = "";
        var targetdeck = this._getDeck(deck);
        if (targetdeck.length > 0) {
          var prefix = deck == "side" ? "!" : "#"; 
          YDK += prefix + deck + "\n"
          for (var i = 0; i < targetdeck.length; i++) {
            YDK += targetdeck[i].ids[0] + "\n";
          }
        }
        return YDK;
      }

      _getDeck(deck) {
        switch (deck) {
          case "main":  return this.mainDeck;  break;
          case "extra": return this.extraDeck; break;
          case "side":  return this.sideDeck;  break;
          default:      return this.mainDeck;  break;
        }
      }

      _setDeck(deck, pendingDeck) {
        switch (deck) {
          case "main":  this.mainDeck  = pendingDeck; break;
          case "extra": this.extraDeck = pendingDeck; break;
          case "side":  this.sideDeck  = pendingDeck; break;
          default:      this.mainDeck  = pendingDeck; break;
        }
      }
    }

    window.customElements.define(DeckManager.is, DeckManager);
  </script>
</dom-module>